# [배열](https://ko.javascript.info/array)

객체는 태생이 순서를 고려하지 않고 만들어진 자료구조이기 때문에 객체를 이용하면 새로운 프로퍼티를 기존 프로퍼티 ‘사이에’ 끼워 넣는 것도 불가능합니다.

이럴 땐 순서가 있는 컬렉션을 저장할 때 쓰는 자료구조인 배열을 사용할 수 있습니다.

## pop·push와 shift·unshift

큐(queue)는 배열을 사용해 만들 수 있는 대표적인 자료구조로, 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는 데 사용합니다. 큐에서 사용하는 주요 연산은 아래와 같습니다.

    push – 맨 끝에 요소를 추가합니다.
    shift – 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어줍니다. 이렇게 하면 두 번째 요소가 첫 번째 요소가 됩니다.

![image](https://user-images.githubusercontent.com/29271126/163291447-ca131663-0eb7-4d19-83a4-05d27feb71b7.png)

배열엔 두 연산을 가능케 해주는 내장 메서드 `push`와 `pop`이 있습니다.
배열은 큐 이외에 스택(stack)이라 불리는 자료구조를 구현할 때도 쓰입니다.

스택에서 사용하는 연산은 아래와 같습니다.

    push – 요소를 스택 끝에 집어넣습니다.
    pop – 스택 끝 요소를 추출합니다.

![image](https://user-images.githubusercontent.com/29271126/163291479-b913803b-6e95-4f03-832f-054ad860c745.png)

스택은 이처럼 '한쪽 끝’에 요소를 더하거나 뺄 수 있게 해주는 자료구조입니다.

스택을 사용하면 가장 나중에 집어넣은 요소가 먼저 나옵니다. 이런 특징을 줄여서 후입선출(Last-In-First-Out, LIFO)이라고 부릅니다. 반면 큐를 사용하면 먼저 집어넣은 요소가 먼저 나오기 때문에 큐는 선입선출(First-In-First-Out, FIFO) 자료구조라고 부릅니다.

이렇게 처음이나 끝에 요소를 더하거나 빼주는 연산을 제공하는 자료구조를 컴퓨터 과학 분야에선 데큐(deque, Double Ended Queue)라고 부릅니다.

### pop

배열 끝 요소를 제거하고, 제거한 요소를 반환합니다.

```javascript
let fruits = ["사과", "오렌지", "배"];

alert(fruits.pop()); // 배열에서 "배"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.

alert(fruits); // 사과,오렌지
```

### push

배열 끝에 요소를 추가합니다.

```javascript
let fruits = ["사과", "오렌지"];

fruits.push("배");

alert(fruits); // 사과,오렌지,배
```

### shift

배열 앞 요소를 제거하고, 제거한 요소를 반환합니다.

```javascript
let fruits = ["사과", "오렌지", "배"];

alert(fruits.shift()); // 배열에서 "사과"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.

alert(fruits); // 오렌지,배
```

### unshift

배열 앞에 요소를 추가합니다.

```javascript
let fruits = ["오렌지", "배"];

fruits.unshift('사과');

alert( fruits ); // 사과,오렌지,배
push와 unshift는 요소 여러 개를 한 번에 더해줄 수도 있습니다.

let fruits = ["사과"];

fruits.push("오렌지", "배");
fruits.unshift("파인애플", "레몬");

// ["파인애플", "레몬", "사과", "오렌지", "배"]
alert( fruits );
```

## 배열의 내부 동작 원리

배열은 특별한 종류의 객체입니다. 배열 arr의 요소를 arr[0]처럼 대괄호를 사용해 접근하는 방식은 객체 문법에서 왔습니다. 다만 배열은 키가 숫자라는 점만 다릅니다.

_배열을 복사할 때 변수에 같은 객체를 바라보게 대입하지 말고 새로운 배열로 만들어 담아야함._

```javascript
let fruits = ["바나나"];

let arr = fruits; // *참조를 복사함(두 변수가 같은 객체를 참조)

alert(arr === fruits); // true

arr.push("배"); // 참조를 이용해 배열을 수정합니다.

alert(fruits); // *바나나,배 - 요소가 두 개가 되었습니다.
```

### 성능

`push`와 `pop`은 빠르지만 `shift`와 `unshift`는 느립니다.

![image](https://user-images.githubusercontent.com/29271126/163292246-46d05cc6-f0df-4a0e-8003-2c69091dd3a9.png)

## 반복문

배열에 적용할 수 있는 또 다른 순회 문법으론 for..of가 있습니다.

```javascript
let fruits = ["사과", "오렌지", "자두"];

// 배열 요소를 대상으로 반복 작업을 수행합니다.
for (let fruit of fruits) {
  alert(fruit);
}
```

for..in은 다음과 같은 특징을 지니기 때문에 배열에 for..in을 사용하면 문제가 발생하므로 되도록 다른 반복문을 사용하시길 바랍니다.

for..in 반복문은 모든 프로퍼티를 대상으로 순회합니다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함됩니다.

1. 브라우저나 기타 호스트 환경에서 쓰이는 객체 중, 배열과 유사한 형태를 보이는 ‘유사 배열(array-like)’ 객체가 있습니다. 유사 배열 객체엔 배열처럼 length 프로퍼티도 있고 요소마다 인덱스도 붙어 있죠. 그런데 여기에 더하여 유사 배열 객체엔 배열과는 달리 키가 숫자형이 아닌 프로퍼티와 메서드가 있을 수 있습니다. 유사 배열 객체와 for..in을 함께 사용하면 이 모든 것을 대상으로 순회가 이뤄집니다. 따라서 ‘필요 없는’ 프로퍼티들이 문제를 일으킬 가능성이 생깁니다.

2. for..in 반복문은 배열이 아니라 객체와 함께 사용할 때 최적화되어 있어서 배열에 사용하면 객체에 사용하는 것 대비 10~100배 정도 느립니다. for..in 반복문의 속도가 대체로 빠른 편이기 때문에 병목 지점에서만 문제가 되긴 합니다만, for..in 반복문을 사용할 땐 이런 차이를 알고 적절한 곳에 사용하시길 바랍니다.

그러니 배열엔 되도록 for..in를 쓰지 마세요!!!.

## toString

배열엔 toString 메서드가 구현되어 있어 이를 호출하면 요소를 쉼표로 구분한 문자열이 반환됩니다.

예시:

```javascript
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
아래 예시를 실행해 봅시다.

alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```

배열엔 Symbol.toPrimitive나 valueOf 메서드가 없습니다. 따라서 위 예시에선 문자열로의 형 변환이 일어나 []는 빈 문자열, [1]은 문자열 "1", [1,2]는 문자열 "1,2"로 변환됩니다.

이항 덧셈 연산자 "+"는 피연산자 중 하나가 문자열인 경우 나머지 피연산자도 문자열로 변환합니다. 따라서 위 예시는 아래 예시와 동일하게 동작합니다.

```javascript
alert("" + 1); // "1"
alert("1" + 1); // "11"
alert("1,2" + 1); // "1,21"
```

## 과제

### 배열과 관련된 연산 (중요도: 5)

배열과 관련된 다섯 가지 연산을 해봅시다.

1. 요소 “Jazz”, "Blues"가 있는 styles 배열을 생성합니다.
2. "Rock-n-Roll"을 배열 끝에 추가합니다.
3. 배열 정 중앙에 있는 요소를 "Classics"로 바꿉니다. 가운데 요소를 찾는 코드는 요소가 홀수 개인 배열에서도 잘 작동해야 합니다.
4. 배열의 첫 번째 요소를 꺼내서 출력합니다.
5. "Rap"과 "Reggae"를 배열의 앞에 추가합니다.

단계를 하나씩 거칠 때마다 배열 모습은 아래와 같이 변해야 합니다.

    Jazz, Blues
    Jazz, Blues, Rock-n-Roll
    Jazz, Classics, Rock-n-Roll
    Classics, Rock-n-Roll
    Rap, Reggae, Classics, Rock-n-Roll

### 배열 컨텍스트에서 함수 호출하기 (중요도: 5)

아래 코드를 실행하면 어떤 결과가 나올까요? 그리고 그 이유는 무엇일까요?

```javascript
let arr = ["a", "b"];

arr.push(function () {
  alert(this);
});

arr[2](); // ?
```

해답

arr[2]()를 호출하는 것은 obj가 arr이고, method는 2인 메서드 obj[method]()를 호출하는 것과 문법적으로 동일합니다.

즉, arr[2]에 있는 함수가 객체 메서드처럼 호출되는 것이죠. 따라서 arr[2]는 arr을 참조하는 this를 받고, 배열을 출력합니다.

```javascript
let arr = ["a", "b"];

arr.push(function () {
  alert(this);
});

arr[2](); // a,b,function(){...}
```

배열은 초기 2개의 값에 함수가 추가되어 총 3개의 값을 가집니다.
